# 第8章　レコード

## 8.1　レコードの必要性

組とは別の構造データとして、レコードがある。  
レコードとは、名前のついてデータの集まりである。  
レコードでは、構造データに含まれる各データに、名前をつけることが出来る。

組と違って、レコードでは順番は意味を持たない。

## 8.2　レコードの構文

```
{名前1 = 値1; 名前2 = 値2}
```

名前のことは「フィールド」という。

## 8.3　レコードとパターンマッチ

レコードも組と同じように、match文によってパターンマッチを使える。  
レコードのパターンは、以下の形になる。

```
{フィールド1 = パターン変数1; フィールド2 = パターン変数2}
```

例。

```ocaml
# match {a = 4; b = 5} with {a = x; b = y} -> x - y ;;
- : int = -1
```

## 8.4　そのほかの記法

本書では使用しないが、以下のような書き方も可能。

- パターン変数とフィールドは、同じ名前でも構わない
- パターンでは、不要なフィールドは省略できる
- match文を使わなくても、`レコード.フィールド`でフィールドの値にアクセスできる

```ocaml
# match {a = 4; b = 5} with {a = a} -> a ;;
- : int = 4
```

```ocaml
# let r = {a = 4} ;;
# r.a ;;
- : int = 4
```

## 8.5　ユーザによる型定義

レコードを使うためにはまずレコードの型を定義し、それが終わってから、レコードを使う関数を定義する必要がある。

`type`文を使うことで、自由に型を定義することが出来る。

```
type 新しく定義する型の名前 = その型の定義
```

レコードの型定義は、以下のように書く。

```
{フィールド1 : 型1; フィールド2 = 型2;}
```

本書では、ユーザ定義の型は全て`_t`で終わることにする。

```ocaml
# type r_t = {a: int} ;;
type r_t = { a : int; }
# let r = {a = 1} ;;
val r : r_t = {a = 1}
# r.a ;;
- : int = 1
```
